---
author: admin
comments: true
date: 2011-03-06 12:15:29+00:00
layout: post
slug: suffixarray
title: 罗穗骞后缀数组倍增算法批注
wordpress_id: 259
categories:
- 算法珠玑
tags:
- 倍增算法
- 后缀数组
- 罗穗骞
---

罗的倍增算法代码看起来很短，其实压行也很严重，所以请看下面重新排版后的代码。

    
    
    int wa[maxn], wb[maxn], wv[maxn], ws[maxn];
    int cmp(int *r, int a, int b, int l)
    {
    	return r[a] == r[b] && r[a + l] == r[b + l];
    }
    
    void da(int *r, int *sa, int n, int m)
    {
    	int i, j, p, *x = wa, *y = wb, *t;
    	for (i = 0; i < m; i++)
    		ws[i] = 0;
    	for (i = 0; i < n; i++)
    		ws[x[i] = r[i]]++;
    	for (i = 1; i < m; i++)
    		ws[i] += ws[i - 1];
    	for (i = n - 1; i >= 0; i--)
    		sa[--ws[x[i]]] = i;
    	for (j = 1, p = 1; p < n; j *= 2, m = p) {
    		for (p = 0, i = n - j; i < n; i++)
    			y[p++] = i;
    		for (i = 0; i < n; i++)
    			if (sa[i] >= j)
    				y[p++] = sa[i] - j;
    		for (i = 0; i < n; i++)
    			wv[i] = x[y[i]];
    		for (i = 0; i < m; i++)
    			ws[i] = 0;
    		for (i = 0; i < n; i++)
    			ws[wv[i]]++;
    		for (i = 1; i < m; i++)
    			ws[i] += ws[i - 1];
    		for (i = n - 1; i >= 0; i--)
    			sa[--ws[wv[i]]] = y[i];
    		for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n;
    		     i++)
    			x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;
    	}
    	return;
    }
    


请读者先自行阅读论文，发现代码中不懂的地方再来本文查阅。
疑点一：x数组到底是干什么的？
其实x数组的作用相当于当前长度前缀的“大小”，或者说“关键值”，也可以说是rank（排第几）。
例如对1、100、8排序，如果不关注数的具体大小，只关注第几个数排第几位的话，和对1、3、2排序其实是一样的。
最开始x数组实际上是原先字符串的单个字符，后来就变成了当前长度前缀的排名了，即x[i]是r[i..i+j-1]在所有同长度前缀的排名。
疑点二：cmp函数为什么要比较r数组？为什么只比较两处？
解答：我最开始就这个问题最纠结，后来发现不是r数组，调用时传入的其实是y数组（也就是原先的x数组）。
原先的两字符串两部分rank分别相同，这两个字符串自然相同了。
疑点三：文中说“按第二关键字排序时利用前一次的结果”具体实现的代码到底什么意思（即代码19到23行）？
解答：字符串第一个字符的下标是0，那么以r[n-j]到r[n-1]为第一个字符的后缀的第二关键字自然都是空，那么就直接把他们放到排序好的数组最前面,因为空是最小的字符串。之后对于以r[sa[i]]开头的长度为j的字符串实际上是以r[sa[i]-j]开头的新长度的后缀的第二关键字，所以他们的大小代表了sa[i]-j的大小。
疑点四：wv数组有什么用？
解答：我个人认为没多大用处，29行可以改成ws[x[i]]++，33行可以改成sa[--ws[x[y[i]]]]=y[i]，常数上并没有增多寻址时间，而且也节省了空间。
以上是我的一点看法和心得，欢迎批评指正！
